"""
CarbonCore FastAPI entry-point  (v0.2.1-frozen)
──────────────────────────────────────────────
• Secure Headers, CORS, global SlowAPI rate-limiting
• JSON logs via core.logging.init_logging
• OTEL traces (auto-disabled if Tempo absent)
• Prometheus /metrics (gzip) via Instrumentator
• Global Pagination (fastapi_pagination)
• Health-/ready probes & blue-green root-path support
• Async Redis via redis.asyncio for rate limiting
• **Graceful fallback if Redis is unreachable**
"""

from __future__ import annotations

# ───────────── stdlib ─────────────
import os
from contextlib import asynccontextmanager
from datetime import UTC, datetime
from importlib import import_module
from typing import Any, Final

# ───────────── 3rd-party ─────────────
import structlog
import uvicorn
from fastapi import Depends, FastAPI, Request, APIRouter
from fastapi.middleware.cors import CORSMiddleware
from fastapi_pagination import add_pagination
from prometheus_fastapi_instrumentator import Instrumentator
from starlette.middleware import Middleware
from fastapi_limiter import FastAPILimiter
from fastapi_limiter.depends import RateLimiter
from redis.asyncio import Redis
from redis.exceptions import ConnectionError as RedisConnectionError

# ───────────── internal ─────────────
import app.otel  # noqa  – sets OTEL env vars early
from app.core.logging import init_logging
from app.core.deps import engine, init_db
from app.core.settings import settings
from app.core.otel import init_otel
from app.core.ratelimit import (
    configure as rl_configure,
    attach as attach_rate_limit,
    limiter,
)
from app.middleware.secure_headers import SecureHeadersMiddleware
from app.registry import registry                     # auto-generated by gen_registry.py
from app.routers.health import router as health_router
from app.routers.gdpr import router as gdpr_router
from app.routers.analytics import router as analytics_router

from pydantic import SecretStr

# ───────────── rate-limit defaults ─────────────
rl_configure(default_limits=[settings.RATE_LIMIT])

# ───────────── logging bootstrap ─────────────
init_logging()
log = structlog.get_logger()

# ───────────── lifespan ─────────────
@asynccontextmanager
async def lifespan(_: FastAPI):
    log.info("lifespan.start", env=settings.ENV)
    await init_db()

    # ---- Redis-backed rate limiter (with safe fallback) ----
    redis_ok = False
    redis_url = os.getenv("REDIS_URL", settings.REDIS_URL or "")
    if redis_url.startswith(("redis://", "rediss://", "unix://")):
        try:
            redis = Redis.from_url(redis_url, encoding="utf-8", decode_responses=True)
            await redis.ping()                # quick connectivity test
            await FastAPILimiter.init(redis)  # 🔒 enable real limits
            redis_ok = True
            log.info("redis.limiter.enabled", url=redis_url)
        except (RedisConnectionError, OSError, ValueError) as exc:
            log.warning("redis.limiter.disabled", err=str(exc))

    if not redis_ok:                          # ➜ no Redis → no-op limiter
        async def _noop_dep():                # substitute dependency
            return None

        def _noop_rate_limiter(*_a, **_kw):
            """Return a FastAPI Depends that always allows."""
            return Depends(_noop_dep)

        # Monkey-patch the globally imported RateLimiter symbol so that
        # any `dependencies=[Depends(RateLimiter(...))]` keep working.
        globals()["RateLimiter"] = _noop_rate_limiter
        # Also stub init so later code can still call it harmlessly.
        class _LazyLimiter:
            async def init(self, *_a, **_kw): ...
            async def close(self): ...
        globals()["FastAPILimiter"] = _LazyLimiter()
        log.warning("rate.limit.fallback", msg="Using in-memory no-op limiter")

    yield
    # ───────── lifespan teardown ─────────
    if redis_ok:
        await FastAPILimiter.close()
    log.info("lifespan.stop")

# ───────────── middleware list ─────────────
MIDDLEWARE: Final[list[Middleware]] = []
if settings.SECURE_HEADERS:
    MIDDLEWARE.append(Middleware(SecureHeadersMiddleware))

# ───────────── FastAPI factory ─────────────
app = FastAPI(
    version=getattr(settings, "BUILD_SHA", None) or "0.2.1-frozen",
    docs_url="/",
    redoc_url=None,
    root_path=f"/{settings.BLUE_GREEN_COLOR}" if settings.BLUE_GREEN_COLOR else "",
    lifespan=lifespan,
    middleware=MIDDLEWARE,
)

# ───────────── core routers ─────────────
app.include_router(health_router)
app.include_router(gdpr_router)
app.include_router(analytics_router)

# ───────────── CORS (wide-open) ─────────────
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ───────────── Plug-in routing ─────────────
for pm in registry.values():
    if pm.mount_point:
        try:
            module_path, func_name = pm.mount_point.split(":")
            registrar = getattr(import_module(module_path), func_name)
            registrar(app)
            log.info("routes.mounted", plugin=pm.id)
        except Exception as exc:  # pragma: no cover
            log.error("routes.mount_failed", plugin=pm.id, err=str(exc))
    for route in pm.routes:
        # Case 1 • Router instance already supplied
        if isinstance(route, APIRouter):
            app.include_router(route)
            log.info("router.mounted", plugin=pm.id, router=route.__class__.__name__)
            continue

        # Case 2 • route handler given as dotted-path string
        try:
            module_path, obj_name = route.handler.split(":")
            target: Any = getattr(import_module(module_path), obj_name)
        except Exception as exc:
            log.error("route.import_failed", plugin=pm.id, err=str(exc))
            continue

        if isinstance(target, APIRouter):
            app.include_router(target, prefix=route.prefix or "")
            log.info("router.mounted", plugin=pm.id, router=target.__class__.__name__)
            continue

        final_path = route.path if route.path.startswith("/") else f"/{route.path}"
        app.add_api_route(
            final_path,
            target,
            methods=[route.method],
            name=f"{pm.id}:{obj_name}",
            include_in_schema=True,
        )
        log.info("route.mounted", plugin=pm.id, path=final_path)

# ───────────── helpers ─────────────
attach_rate_limit(app)
add_pagination(app)

# ───────────── probes ─────────────
@limiter.limit("1/minute", key_func=lambda *_a, **_k: "health-burst")
@app.get("/healthz", include_in_schema=False)
async def healthz(request: Request) -> dict[str, str]:   # ← name MUST be “request”
    return {
        "status": "ok",
        "ts": datetime.now(UTC).isoformat(timespec="seconds"),
    }

@app.get("/readyz", include_in_schema=False)
async def readyz() -> dict[str, str]:
    # INSTANCE_ID might be missing *or* a pydantic SecretStr/UUID/etc.
    raw_instance = getattr(settings, "INSTANCE_ID", None)
    if isinstance(raw_instance, SecretStr):               # SecretStr → unwrap first
        raw_instance = raw_instance.get_secret_value()
    instance = str(raw_instance) if raw_instance else "local"

    color = str(getattr(settings, "BLUE_GREEN_COLOR", "") or "default")

    return {
        "status": "ready",
        "instance": instance,
        "color": color,
    }



# # ───────────── health / ready probes ─────────────
# @limiter.limit("1/minute", key_func=lambda *_a, **_k: "health-burst")   # still safe if no-op
# @app.get("/healthz", include_in_schema=False)
# async def healthz(_: Request) -> dict[str, str]:
#     return {"status": "ok", "ts": datetime.now(UTC).isoformat(timespec="seconds")}

# @app.get("/readyz", include_in_schema=False)
# async def readyz() -> dict[str, str]:
#     return {
#         "status": "ready",
#         "instance": settings.INSTANCE_ID,
#         "color": settings.BLUE_GREEN_COLOR or "default",
#     }

# ───────────── Prometheus ─────────────
if settings.ENABLE_METRICS:
    Instrumentator().instrument(app).expose(
        app, endpoint="/metrics", include_in_schema=False, should_gzip=True
    )
    log.info("prometheus.enabled")

# ───────────── OpenTelemetry ─────────────
if settings.ENABLE_TRACING:
    try:
        init_otel(app, engine)
        log.info("otel.enabled")
    except Exception as exc:          # pragma: no cover
        log.warning("otel.disabled", err=str(exc))

log.info("app.initialised")

# ───────────── Local dev runner ─────────────
if __name__ == "__main__":            # pragma: no cover
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        reload_includes=["*.py"],
    )
